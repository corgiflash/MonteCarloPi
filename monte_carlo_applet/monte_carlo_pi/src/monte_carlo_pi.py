#!/usr/bin/env python
# monte_carlo_pi 0.0.1
# Generated by dx-app-wizard.
#
# Parallelized execution pattern: Your app will generate multiple jobs
# to perform some computation in parallel, followed by a final
# "postprocess" stage that will perform any additional computations as
# necessary.
#
# See https://wiki.dnanexus.com/Developer-Portal for documentation and
# tutorials on how to modify this file.
#
# DNAnexus Python Bindings (dxpy) documentation:
#   http://autodoc.dnanexus.com/bindings/python/current/

from math import ceil
from multiprocessing import Pool, Lock, Value, cpu_count

import os
import random
import dxpy

@dxpy.entry_point("postprocess")
def postprocess(process_outputs, total_count):
    # The postprocesses sums the number of points simulated
    # that fall within a unit circle, as reported by each process
    # output, and returns the overall estimate of Pi based on total_count
    # number of simulations

    estimatedPi = 4 * sum(process_outputs) / float(total_count)
    print "Estimated value of pi: %.5f" %estimatedPi

    return { "answer":  estimatedPi}

# Global Variables for sharing resources between processes
lock = Lock()
nWithinCircle = 0

def tallyCount(result):
    '''Callback method used to total # of points that are
    simulated which fell within the unit circle'''
    global lock, nWithinCircle
    lock.acquire()
    nWithinCircle += result
    lock.release()

def isInCircle(x,y):
    '''Returns true when a point, given as (x,y)
    falls within the unit circle, and false otherwise'''
    return (x**2 + y**2) < 1

def simulateNPoints(n):
    '''Simulate n random points in the space ([0,1], [0,1]) using random 
    numbers and returns the number of points (of n) which falls within 
    the unit circle'''
    result = 0
    for _ in xrange(n):
        (x, y) = (random.random(), random.random())
        if isInCircle(x, y):
            result += 1
    return result

def splitIntoGroups(total, nGroups):
    '''Given an int total, return a list containing nGroups ints,
    where the numerical value of each element is in the range
    [total/nGroups, total/nGroups + 1]  and the sum of all elements is 
    equivalent to total''' 
    baseDelegates = total / nGroups
    delegations = [baseDelegates for _ in range(nGroups)]
    for i in range(total % nGroups):
        delegations[i] += 1
    return delegations

@dxpy.entry_point("process")
def simulatePoints(workerLoad):
    # Change the following to process whatever input this stage
    # receives.  You may also want to copy and paste the logic to download
    # and upload files here as well if this stage receives file input
    # and/or makes file output.

    # Simulate workerLoad number of points in the unit square space
    # and returns the fraction of points that are within the bounds 
    # of the unit circle as a fraction


    # # Non-parallelized implmentation
    # result = 0
    # for _ in xrange(workerLoad):
    #     (x, y) = (random.random(), random.random())
    #     if isInCircle(x, y):
    #         result += 1

    # return { "output": result / float(workerLoad) }

    # Parallelized setup using pool
    numCPU = cpu_count()
    pool = Pool()

    print "Set up pool with %d processes" %(numCPU)

    delegations = splitIntoGroups(workerLoad, numCPU)


    for n in delegations:
        pool.apply_async(simulateNPoints, args=(n,), callback=tallyCount)
        
    pool.close()
    pool.join()
    
    return { "output": nWithinCircle}

@dxpy.entry_point("main")
def main(nSimulations, nWorkers):

    # To achieve a target of nSimulations total simulations,
    # an approximately equal share of simulations is delegated to each
    # worker initiated

    subjobs = []
    workerLoads = splitIntoGroups(nSimulations, nWorkers)

    
    for load in workerLoads:
        subjob_input = { "workerLoad": load}
        subjobs.append(dxpy.new_dxjob(subjob_input, "process"))

    # The postprocess job depends on all subjobs being "done"

    postprocess_job = dxpy.new_dxjob(fn_input={ "process_outputs": [subjob.get_output_ref("output") for subjob in subjobs],
                                                "total_count": nSimulations },
                                     fn_name="postprocess",
                                     depends_on=subjobs)

    output = {"estimatedPi": postprocess_job.get_output_ref("answer")}
    return output

dxpy.run()
